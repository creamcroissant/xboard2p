name: Release

on:
  push:
    tags:
      - 'v*'

permissions:
  contents: write
  packages: write

env:
  GO_VERSION: '1.25'
  NODE_VERSION: '20'

jobs:
  build-frontend:
    name: Build Frontend Assets
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Build User Frontend
        working-directory: web/user-vite
        run: |
          npm ci
          npm run build

      - name: Upload frontend artifact
        uses: actions/upload-artifact@v4
        with:
          name: frontend-dist
          path: web/user-vite/dist
          if-no-files-found: error

  build-binaries:
    name: Build ${{ matrix.goos }}/${{ matrix.goarch }}
    runs-on: ubuntu-latest
    needs: build-frontend
    strategy:
      fail-fast: false
      matrix:
        include:
          - goos: linux
            goarch: amd64
            ext: ''
          - goos: linux
            goarch: arm64
            ext: ''
          - goos: darwin
            goarch: amd64
            ext: ''
          - goos: darwin
            goarch: arm64
            ext: ''
          - goos: windows
            goarch: amd64
            ext: '.exe'

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Download frontend artifact
        uses: actions/download-artifact@v4
        with:
          name: frontend-dist
          path: web/user-vite/dist

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Get version info
        id: version
        run: |
          echo "version=${GITHUB_REF#refs/tags/}" >> "$GITHUB_OUTPUT"
          echo "commit=$(git rev-parse --short HEAD)" >> "$GITHUB_OUTPUT"
          echo "build_time=$(date -u '+%Y-%m-%dT%H:%M:%SZ')" >> "$GITHUB_OUTPUT"

      - name: Build binaries
        env:
          GOOS: ${{ matrix.goos }}
          GOARCH: ${{ matrix.goarch }}
          EXT: ${{ matrix.ext }}
        run: |
          set -euo pipefail

          mkdir -p dist/release

          XBOARD_BIN="xboard-${GOOS}-${GOARCH}${EXT}"
          AGENT_BIN="agent-${GOOS}-${GOARCH}${EXT}"

          echo "Building ${XBOARD_BIN}"
          go build -trimpath \
            -ldflags "-s -w -X main.Version=${{ steps.version.outputs.version }} -X main.Commit=${{ steps.version.outputs.commit }} -X main.BuildTime=${{ steps.version.outputs.build_time }}" \
            -o "dist/release/${XBOARD_BIN}" \
            ./cmd/xboard

          echo "Building ${AGENT_BIN}"
          go build -trimpath \
            -ldflags "-s -w" \
            -o "dist/release/${AGENT_BIN}" \
            ./cmd/agent

          sha256sum "dist/release/${XBOARD_BIN}" > "dist/release/${XBOARD_BIN}.sha256"
          sha256sum "dist/release/${AGENT_BIN}" > "dist/release/${AGENT_BIN}.sha256"

      - name: Upload release artifact
        uses: actions/upload-artifact@v4
        with:
          name: release-${{ matrix.goos }}-${{ matrix.goarch }}
          path: dist/release/*
          if-no-files-found: error

  release:
    name: Create Release
    runs-on: ubuntu-latest
    needs: build-binaries
    steps:
      - uses: actions/checkout@v4

      - name: Download release artifacts
        uses: actions/download-artifact@v4
        with:
          path: dist/release
          pattern: release-*
          merge-multiple: true

      - name: Verify expected binaries exist
        run: |
          set -euo pipefail
          test -f dist/release/xboard-linux-amd64
          test -f dist/release/xboard-linux-arm64
          test -f dist/release/xboard-darwin-amd64
          test -f dist/release/xboard-darwin-arm64
          test -f dist/release/xboard-windows-amd64.exe

          test -f dist/release/agent-linux-amd64
          test -f dist/release/agent-linux-arm64
          test -f dist/release/agent-darwin-amd64
          test -f dist/release/agent-darwin-arm64
          test -f dist/release/agent-windows-amd64.exe

      - name: Verify deploy script shell compatibility
        run: |
          set -euo pipefail

          sh -n deploy/common.sh deploy/install.sh deploy/panel.sh deploy/agent.sh deploy/agent-bootstrap.sh
          bash -n deploy/common.sh deploy/install.sh deploy/panel.sh deploy/agent.sh deploy/agent-bootstrap.sh

          WORKDIR_SH="$(mktemp -d)"
          WORKDIR_BASH="$(mktemp -d)"
          trap 'rm -rf "${WORKDIR_SH}" "${WORKDIR_BASH}"' EXIT

          cp dist/release/agent-linux-amd64 "${WORKDIR_SH}/agent"
          cp deploy/install.sh "${WORKDIR_SH}/install.sh"
          cp deploy/panel.sh "${WORKDIR_SH}/panel.sh"
          cp deploy/agent.sh "${WORKDIR_SH}/agent.sh"
          cp deploy/common.sh "${WORKDIR_SH}/common.sh"
          cp deploy/agent.service "${WORKDIR_SH}/agent.service"
          cp deploy/agent-bootstrap.sh "${WORKDIR_SH}/agent-bootstrap.sh"
          cp deploy/agent-bootstrap.sha256 "${WORKDIR_SH}/agent-bootstrap.sha256"

          cp dist/release/agent-linux-amd64 "${WORKDIR_BASH}/agent"
          cp deploy/install.sh "${WORKDIR_BASH}/install.sh"
          cp deploy/panel.sh "${WORKDIR_BASH}/panel.sh"
          cp deploy/agent.sh "${WORKDIR_BASH}/agent.sh"
          cp deploy/common.sh "${WORKDIR_BASH}/common.sh"
          cp deploy/agent.service "${WORKDIR_BASH}/agent.service"
          cp deploy/agent-bootstrap.sh "${WORKDIR_BASH}/agent-bootstrap.sh"
          cp deploy/agent-bootstrap.sha256 "${WORKDIR_BASH}/agent-bootstrap.sha256"

          mkdir -p "${WORKDIR_SH}/local/local/releases/download/local" "${WORKDIR_BASH}/local/local/releases/download/local"
          cp dist/release/agent-linux-amd64 "${WORKDIR_SH}/local/local/releases/download/local/agent-linux-amd64"
          cp dist/release/agent-linux-amd64 "${WORKDIR_BASH}/local/local/releases/download/local/agent-linux-amd64"

          chmod +x "${WORKDIR_SH}/agent" "${WORKDIR_SH}/install.sh" "${WORKDIR_SH}/panel.sh" "${WORKDIR_SH}/agent.sh" "${WORKDIR_SH}/common.sh" "${WORKDIR_SH}/agent-bootstrap.sh"
          chmod +x "${WORKDIR_BASH}/agent" "${WORKDIR_BASH}/install.sh" "${WORKDIR_BASH}/panel.sh" "${WORKDIR_BASH}/agent.sh" "${WORKDIR_BASH}/common.sh" "${WORKDIR_BASH}/agent-bootstrap.sh"

          if [ "$(sha256sum "${WORKDIR_SH}/agent.sh" | awk '{print $1}')" != "$(awk '/[[:space:]]agent\.sh$/ {print $1}' "${WORKDIR_SH}/agent-bootstrap.sha256')" ]; then
            echo "agent.sh checksum mismatch against deploy/agent-bootstrap.sha256" >&2
            exit 1
          fi
          if [ "$(sha256sum "${WORKDIR_SH}/common.sh" | awk '{print $1}')" != "$(awk '/[[:space:]]common\.sh$/ {print $1}' "${WORKDIR_SH}/agent-bootstrap.sha256')" ]; then
            echo "common.sh checksum mismatch against deploy/agent-bootstrap.sha256" >&2
            exit 1
          fi
          if [ "$(sha256sum "${WORKDIR_SH}/agent.service" | awk '{print $1}')" != "$(awk '/[[:space:]]agent\.service$/ {print $1}' "${WORKDIR_SH}/agent-bootstrap.sha256')" ]; then
            echo "agent.service checksum mismatch against deploy/agent-bootstrap.sha256" >&2
            exit 1
          fi

          (
            cd "${WORKDIR_SH}"
            XBOARD_INSTALL_SKIP_SYSTEMD=1 INSTALL_DIR="${WORKDIR_SH}/out" sh ./install.sh --agent-only
            test -x "${WORKDIR_SH}/out/agent"
            test -f "${WORKDIR_SH}/out/agent_config.yml"
          )

          (
            cd "${WORKDIR_BASH}"
            XBOARD_INSTALL_SKIP_SYSTEMD=1 INSTALL_DIR="${WORKDIR_BASH}/out" bash ./install.sh --agent-only
            test -x "${WORKDIR_BASH}/out/agent"
            test -f "${WORKDIR_BASH}/out/agent_config.yml"
          )

          (
            cd "${WORKDIR_SH}"
            XBOARD_INSTALL_SKIP_SYSTEMD=1 INSTALL_DIR="${WORKDIR_SH}/bootstrap-out" XBOARD_BOOTSTRAP_REF=local \
            XBOARD_RELEASE_BASE_URL="file://${WORKDIR_SH}" \
            XBOARD_AGENT_SCRIPT_URL="file://${WORKDIR_SH}/agent.sh" XBOARD_COMMON_SCRIPT_URL="file://${WORKDIR_SH}/common.sh" \
            sh ./agent-bootstrap.sh \
              --repo local/local \
              --service-url "file://${WORKDIR_SH}/agent.service" \
              --checksum-url "file://${WORKDIR_SH}/agent-bootstrap.sha256"
            test -x "${WORKDIR_SH}/bootstrap-out/agent"
            test -f "${WORKDIR_SH}/bootstrap-out/agent_config.yml"
          )

          (
            cd "${WORKDIR_BASH}"
            XBOARD_INSTALL_SKIP_SYSTEMD=1 INSTALL_DIR="${WORKDIR_BASH}/bootstrap-out" XBOARD_BOOTSTRAP_REF=local \
            XBOARD_RELEASE_BASE_URL="file://${WORKDIR_BASH}" \
            XBOARD_AGENT_SCRIPT_URL="file://${WORKDIR_BASH}/agent.sh" XBOARD_COMMON_SCRIPT_URL="file://${WORKDIR_BASH}/common.sh" \
            bash ./agent-bootstrap.sh \
              --repo local/local \
              --service-url "file://${WORKDIR_BASH}/agent.service" \
              --checksum-url "file://${WORKDIR_BASH}/agent-bootstrap.sha256"
            test -x "${WORKDIR_BASH}/bootstrap-out/agent"
            test -f "${WORKDIR_BASH}/bootstrap-out/agent_config.yml"
          )

          cp "${WORKDIR_SH}/agent.service" "${WORKDIR_SH}/agent.service.local-fallback"
          cp "${WORKDIR_SH}/agent.service" "${WORKDIR_SH}/agent.service.bad"
          printf '\n# checksum mismatch fixture\n' >> "${WORKDIR_SH}/agent.service.bad"

          (
            cd "${WORKDIR_SH}"
            XBOARD_INSTALL_SKIP_SYSTEMD=1 INSTALL_DIR="${WORKDIR_SH}/bootstrap-checksum-fallback-out" XBOARD_BOOTSTRAP_REF=local \
            XBOARD_RELEASE_BASE_URL="file://${WORKDIR_SH}" \
            XBOARD_AGENT_SCRIPT_URL="file://${WORKDIR_SH}/agent.sh" XBOARD_COMMON_SCRIPT_URL="file://${WORKDIR_SH}/common.sh" \
            XBOARD_AGENT_SERVICE_FILE="${WORKDIR_SH}/agent.service.local-fallback" \
            XBOARD_BOOTSTRAP_DOWNLOAD_STRICT=0 \
            sh ./agent-bootstrap.sh \
              --repo local/local \
              --service-url "file://${WORKDIR_SH}/agent.service.bad" \
              --checksum-url "file://${WORKDIR_SH}/agent-bootstrap.sha256"
            test -x "${WORKDIR_SH}/bootstrap-checksum-fallback-out/agent"
            test -f "${WORKDIR_SH}/bootstrap-checksum-fallback-out/agent_config.yml"
          )

          (
            cd "${WORKDIR_SH}"
            if XBOARD_INSTALL_SKIP_SYSTEMD=1 INSTALL_DIR="${WORKDIR_SH}/bootstrap-checksum-strict-out" XBOARD_BOOTSTRAP_REF=local \
              XBOARD_RELEASE_BASE_URL="file://${WORKDIR_SH}" \
              XBOARD_AGENT_SCRIPT_URL="file://${WORKDIR_SH}/agent.sh" XBOARD_COMMON_SCRIPT_URL="file://${WORKDIR_SH}/common.sh" \
              XBOARD_AGENT_SERVICE_FILE="${WORKDIR_SH}/agent.service.local-fallback" \
              XBOARD_BOOTSTRAP_DOWNLOAD_STRICT=1 \
              sh ./agent-bootstrap.sh \
                --repo local/local \
                --service-url "file://${WORKDIR_SH}/agent.service.bad" \
                --checksum-url "file://${WORKDIR_SH}/agent-bootstrap.sha256"; then
              echo "agent-bootstrap should fail when agent.service checksum mismatches in strict mode" >&2
              exit 1
            fi
          )

          (
            cd "${WORKDIR_SH}"
            XBOARD_INSTALL_SKIP_SYSTEMD=1 INSTALL_DIR="${WORKDIR_SH}/bootstrap-download-fallback-out" XBOARD_BOOTSTRAP_REF=local \
            XBOARD_RELEASE_BASE_URL="file://${WORKDIR_SH}" \
            XBOARD_AGENT_SCRIPT_URL="file://${WORKDIR_SH}/agent.sh" XBOARD_COMMON_SCRIPT_URL="file://${WORKDIR_SH}/common.sh" \
            XBOARD_AGENT_SERVICE_FILE="${WORKDIR_SH}/agent.service.local-fallback" \
            XBOARD_BOOTSTRAP_DOWNLOAD_STRICT=0 \
            sh ./agent-bootstrap.sh \
              --repo local/local \
              --service-url "file://${WORKDIR_SH}/missing-agent.service" \
              --checksum-url "file://${WORKDIR_SH}/agent-bootstrap.sha256"
            test -x "${WORKDIR_SH}/bootstrap-download-fallback-out/agent"
            test -f "${WORKDIR_SH}/bootstrap-download-fallback-out/agent_config.yml"
          )

      - name: Set up Go for install config check
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Verify install config compatibility (gRPC-only)
        run: |
          set -euo pipefail

          WORKDIR="$(mktemp -d)"
          VALIDATE_GO="${GITHUB_WORKSPACE}/tmp_validate_agent_config.go"
          trap 'rm -rf "${WORKDIR}"; rm -f "${VALIDATE_GO}"' EXIT

          cp dist/release/agent-linux-amd64 "${WORKDIR}/agent"
          cp deploy/install.sh "${WORKDIR}/install.sh"
          cp deploy/panel.sh "${WORKDIR}/panel.sh"
          cp deploy/agent.sh "${WORKDIR}/agent.sh"
          cp deploy/common.sh "${WORKDIR}/common.sh"

          chmod +x "${WORKDIR}/agent" "${WORKDIR}/install.sh" "${WORKDIR}/panel.sh" "${WORKDIR}/agent.sh" "${WORKDIR}/common.sh"

          (
            cd "${WORKDIR}"
            XBOARD_INSTALL_SKIP_SYSTEMD=1 INSTALL_DIR="${WORKDIR}/out" sh ./install.sh --agent-only
            test -f "${WORKDIR}/out/agent_config.yml"
          )

          cat > "${VALIDATE_GO}" <<'EOF'
          package main

          import (
            "fmt"
            "os"

            agentcfg "github.com/creamcroissant/xboard/internal/agent/config"
          )

          func main() {
            if len(os.Args) != 2 {
              fmt.Fprintln(os.Stderr, "usage: validate_agent_config <path>")
              os.Exit(2)
            }
            if _, err := agentcfg.Load(os.Args[1]); err != nil {
              fmt.Fprintln(os.Stderr, err)
              os.Exit(1)
            }
          }
          EOF

          if ! grep -Eq '^[[:space:]]*grpc:' "${WORKDIR}/out/agent_config.yml"; then
            echo "agent_config.yml missing grpc section" >&2
            exit 1
          fi
          if ! grep -Eq '^[[:space:]]*enabled:[[:space:]]*true[[:space:]]*$' "${WORKDIR}/out/agent_config.yml"; then
            echo "agent_config.yml missing grpc.enabled=true" >&2
            exit 1
          fi
          if ! grep -Eq '^[[:space:]]*address:[[:space:]]*""[[:space:]]*$' "${WORKDIR}/out/agent_config.yml"; then
            echo "agent_config.yml should require manual grpc.address override" >&2
            exit 1
          fi
          if grep -Eq '^[[:space:]]*address:[[:space:]]*"127\.0\.0\.1:9090"[[:space:]]*$' "${WORKDIR}/out/agent_config.yml"; then
            echo "agent_config.yml must not keep default grpc.address=127.0.0.1:9090" >&2
            exit 1
          fi
          if ! grep -Eq '^[[:space:]]*panel:' "${WORKDIR}/out/agent_config.yml"; then
            echo "agent_config.yml missing panel section" >&2
            exit 1
          fi
          if ! grep -Eq '^[[:space:]]*host_token:[[:space:]]*""[[:space:]]*$' "${WORKDIR}/out/agent_config.yml"; then
            echo "agent_config.yml should require manual panel.host_token override" >&2
            exit 1
          fi
          if grep -Eq '^[[:space:]]*host_token:[[:space:]]*"change_me"[[:space:]]*$' "${WORKDIR}/out/agent_config.yml"; then
            echo "agent_config.yml must not keep placeholder panel.host_token" >&2
            exit 1
          fi
          if ! grep -Eq '^[[:space:]]*traffic:' "${WORKDIR}/out/agent_config.yml"; then
            echo "agent_config.yml missing traffic section" >&2
            exit 1
          fi
          if ! grep -Eq '^[[:space:]]*type:[[:space:]]*"netio"[[:space:]]*$' "${WORKDIR}/out/agent_config.yml"; then
            echo "agent_config.yml should default traffic.type=netio" >&2
            exit 1
          fi
          if grep -Eq '^[[:space:]]*token:[[:space:]]*' "${WORKDIR}/out/agent_config.yml"; then
            echo "agent_config.yml should not contain legacy panel.token" >&2
            exit 1
          fi
          if grep -Eq '^[[:space:]]*node_id:[[:space:]]*' "${WORKDIR}/out/agent_config.yml"; then
            echo "agent_config.yml should not contain legacy panel.node_id" >&2
            exit 1
          fi

          if go run "${VALIDATE_GO}" "${WORKDIR}/out/agent_config.yml"; then
            echo "agent_config.yml should fail validation before real token/address override" >&2
            exit 1
          fi

          python3 -c 'from pathlib import Path; import sys; text = Path(sys.argv[1]).read_text(); text = text.replace("host_token: \"\"", "host_token: \"release-check-token\"", 1); text = text.replace("address: \"\"", "address: \"127.0.0.1:19090\"", 1); Path(sys.argv[2]).write_text(text)' "${WORKDIR}/out/agent_config.yml" "${WORKDIR}/out/agent_config.runtime.yml"

          go run "${VALIDATE_GO}" "${WORKDIR}/out/agent_config.runtime.yml"
          rm -f "${VALIDATE_GO}" "${WORKDIR}/out/agent_config.runtime.yml"

      - name: Merge checksums
        run: |
          set -euo pipefail

          cat dist/release/*.sha256 > dist/release/SHA256SUMS.txt
          sha256sum deploy/agent.sh deploy/common.sh deploy/agent.service >> dist/release/SHA256SUMS.txt
          sort -k2 dist/release/SHA256SUMS.txt -o dist/release/SHA256SUMS.txt

      - name: Publish release assets
        uses: softprops/action-gh-release@v2
        with:
          files: |
            dist/release/xboard-*
            dist/release/agent-*
            dist/release/SHA256SUMS.txt
          generate_release_notes: true
          draft: false
          prerelease: ${{ contains(github.ref, 'alpha') || contains(github.ref, 'beta') || contains(github.ref, 'rc') }}

  cloudpaste-upload:
    name: Sync assets to CloudPaste
    runs-on: ubuntu-latest
    needs: release
    env:
      CLOUDPASTE_API_ENDPOINT: ${{ secrets.CLOUDPASTE_API_ENDPOINT }}
      CLOUDPASTE_API_KEY: ${{ secrets.CLOUDPASTE_API_KEY }}
      CLOUDPASTE_STORAGE_CONFIG_ID: ${{ secrets.CLOUDPASTE_STORAGE_CONFIG_ID }}
      CLOUDPASTE_SLUG_PREFIX: ${{ secrets.CLOUDPASTE_SLUG_PREFIX }}
    steps:
      - name: Download release artifacts
        uses: actions/download-artifact@v4
        with:
          path: dist/release
          pattern: release-*
          merge-multiple: true

      - name: Verify expected agent binaries exist
        run: |
          set -euo pipefail
          test -f dist/release/agent-linux-amd64
          test -f dist/release/agent-linux-arm64
          test -f dist/release/agent-darwin-amd64
          test -f dist/release/agent-darwin-arm64
          test -f dist/release/agent-windows-amd64.exe

      - name: Merge checksums for verification
        run: |
          set -euo pipefail
          cd dist/release
          cat *.sha256 | sort -k2 > SHA256SUMS.txt

      - name: Upload release assets to CloudPaste
        env:
          TAG_NAME: ${{ github.ref_name }}
        run: |
          set -euo pipefail

          if [ -z "${CLOUDPASTE_API_ENDPOINT}" ] || [ -z "${CLOUDPASTE_API_KEY}" ]; then
            echo "CloudPaste secrets are not fully configured." >&2
            exit 1
          fi

          endpoint="${CLOUDPASTE_API_ENDPOINT%/}"
          api_base="${endpoint}"
          if [[ "${api_base}" != */api && "${api_base}" != */api/* ]]; then
            api_base="${api_base}/api"
          fi

          slug_prefix="$(printf '%s' "${CLOUDPASTE_SLUG_PREFIX:-xboard}" | tr '[:upper:]' '[:lower:]' | sed -E 's/[^a-z0-9]+/-/g; s/^-+//; s/-+$//')"
          if [ -z "${slug_prefix}" ]; then
            slug_prefix="xboard"
          fi

          channel="stable"
          tag_name_lc="$(printf '%s' "${TAG_NAME}" | tr '[:upper:]' '[:lower:]')"
          if [[ "${tag_name_lc}" == *alpha* || "${tag_name_lc}" == *beta* || "${tag_name_lc}" == *rc* ]]; then
            channel="pre"
          fi

          assets=(
            "agent-linux-amd64"
            "agent-linux-arm64"
            "agent-darwin-amd64"
            "agent-darwin-arm64"
            "agent-windows-amd64.exe"
          )

          {
            echo "## CloudPaste Upload Summary"
            echo
            echo "- Channel: \`${channel}\`"
            echo "- storage_config_id: \`${CLOUDPASTE_STORAGE_CONFIG_ID:-default}\`"
            echo
            echo "| Asset | Final Slug | Download URL | HTTP code | SHA check |"
            echo "| --- | --- | --- | --- | --- |"
          } >> "${GITHUB_STEP_SUMMARY}"

          verify_queue_file="$(mktemp)"
          : > cloudpaste_verify_results.jsonl

          for asset in "${assets[@]}"; do
            file_path="dist/release/${asset}"
            if [ ! -f "${file_path}" ]; then
              echo "Missing release asset: ${file_path}" >&2
              exit 1
            fi
            file_sha="$(sha256sum "${file_path}" | awk '{print $1}')"

            asset_slug_token="$(printf '%s' "${asset}" | tr '[:upper:]' '[:lower:]' | sed -E 's/[^a-z0-9._-]+/-/g; s/[.]+/-/g; s/-+/-/g; s/^-+//; s/-+$//')"
            expected_slug="${slug_prefix}-${channel}-${asset_slug_token}"
            slug_encoded="$(python3 -c 'import sys, urllib.parse; print(urllib.parse.quote(sys.argv[1], safe=""))' "${expected_slug}")"
            upload_url="${api_base}/upload-direct/${asset}?slug=${slug_encoded}&override=true"
            if [ -n "${CLOUDPASTE_STORAGE_CONFIG_ID}" ]; then
              upload_url="${upload_url}&storage_config_id=${CLOUDPASTE_STORAGE_CONFIG_ID}"
            fi

            response_file="$(mktemp)"
            http_code="$(
              curl --silent --show-error --location --request PUT \
                --header "Authorization: ApiKey ${CLOUDPASTE_API_KEY}" \
                --header "Content-Type: application/octet-stream" \
                --data-binary @"${file_path}" \
                --output "${response_file}" \
                --write-out "%{http_code}" \
                "${upload_url}"
            )"

            if [[ ! "${http_code}" =~ ^2 ]]; then
              echo "CloudPaste upload failed for ${asset} (HTTP ${http_code})." >&2
              cat "${response_file}" >&2
              rm -f "${response_file}"
              exit 1
            fi

            actual_slug="$(python3 -c 'import json,sys; p=json.load(open(sys.argv[1], encoding="utf-8")); d=p.get("data") if isinstance(p.get("data"), dict) else {}; r=p.get("result") if isinstance(p.get("result"), dict) else {}; pick=lambda *v: next((x for x in v if isinstance(x, str) and x.strip()), ""); print(pick(p.get("slug"), d.get("slug"), r.get("slug")))' "${response_file}")"
            download_url="$(python3 -c 'import json,sys; p=json.load(open(sys.argv[1], encoding="utf-8")); d=p.get("data") if isinstance(p.get("data"), dict) else {}; r=p.get("result") if isinstance(p.get("result"), dict) else {}; pick=lambda *v: next((x for x in v if isinstance(x, str) and x.strip()), ""); print(pick(p.get("downloadUrl"), p.get("download_url"), d.get("downloadUrl"), d.get("download_url"), r.get("downloadUrl"), r.get("download_url")))' "${response_file}")"
            api_success="$(python3 -c 'import json,sys; p=json.load(open(sys.argv[1], encoding="utf-8")); s=(p.get("success") is True); c=str(p.get("code", "")); st=str(p.get("status", "")).lower(); print("1" if (s or c in ("0", "200", "ok", "OK") or st in ("success", "ok")) else "0")' "${response_file}")"

            if [ "${api_success}" != "1" ]; then
              echo "CloudPaste upload API indicated failure for ${asset}." >&2
              cat "${response_file}" >&2
              rm -f "${response_file}"
              exit 1
            fi

            if [ "${actual_slug}" != "${expected_slug}" ]; then
              alternate_channel="stable"
              if [ "${channel}" = "stable" ]; then
                alternate_channel="pre"
              fi
              alternate_slug="${slug_prefix}-${alternate_channel}-${asset_slug_token}"

              if [ "${actual_slug}" = "${alternate_slug}" ]; then
                echo "Slug channel drift for ${asset}: expected ${expected_slug}, got ${actual_slug}. Keeping upload as success."
              else
                echo "Slug mismatch for ${asset}: expected ${expected_slug}, got ${actual_slug}" >&2
                cat "${response_file}" >&2
                rm -f "${response_file}"
                exit 1
              fi
            fi

            if [ -z "${download_url}" ]; then
              download_url="${api_base}/s/${actual_slug}"
              echo "downloadUrl is empty for ${asset}, fallback to ${download_url}."
            elif [[ "${download_url}" = /* ]]; then
              download_url="${endpoint}${download_url}"
            fi

            verify_alt_channel="stable"
            if [ "${channel}" = "stable" ]; then
              verify_alt_channel="pre"
            fi
            verify_alt_slug="${slug_prefix}-${verify_alt_channel}-${asset_slug_token}"
            verify_alt_url="${api_base}/s/${verify_alt_slug}"

            verify_urls=("${download_url}")
            if [ "${verify_alt_slug}" != "${actual_slug}" ] && [ "${verify_alt_url}" != "${download_url}" ]; then
              verify_urls+=("${verify_alt_url}")
            fi

            verify_urls_joined="$(printf '%s|' "${verify_urls[@]}")"
            verify_urls_joined="${verify_urls_joined%|}"

            printf '{"asset":"%s","expected_slug":"%s","actual_slug":"%s","download_url":"%s","verify_urls":"%s","http_code":"","expected_sha":"%s","actual_sha":"","sha_match":false}\n' \
              "${asset}" "${expected_slug}" "${actual_slug}" "${download_url}" "${verify_urls_joined}" "${file_sha}" >> "${verify_queue_file}"

            rm -f "${response_file}"
          done

          echo "Starting CloudPaste verification sweep for all uploaded assets..."
          verify_initial_delay=20
          if [ "${verify_initial_delay}" -gt 0 ]; then
            echo "Waiting ${verify_initial_delay}s for CloudPaste propagation before verification..."
            sleep "${verify_initial_delay}"
          fi
          verify_max_attempts=48
          verify_retry_sleep=5
          queue_size="$(wc -l < "${verify_queue_file}" | tr -d '[:space:]')"

          for attempt in $(seq 1 ${verify_max_attempts}); do
            if [ "${queue_size}" = "0" ]; then
              break
            fi

            echo "CloudPaste verify attempt ${attempt}/${verify_max_attempts} for ${queue_size} pending asset(s)."

            next_queue_file="$(mktemp)"
            : > "${next_queue_file}"

            while IFS= read -r entry; do
              [ -z "${entry}" ] && continue

              asset="$(python3 -c 'import json,sys; print(json.loads(sys.argv[1])["asset"])' "${entry}")"
              actual_slug="$(python3 -c 'import json,sys; print(json.loads(sys.argv[1])["actual_slug"])' "${entry}")"
              expected_sha="$(python3 -c 'import json,sys; print(json.loads(sys.argv[1])["expected_sha"])' "${entry}")"
              verify_urls_joined="$(python3 -c 'import json,sys; print(json.loads(sys.argv[1])["verify_urls"])' "${entry}")"
              IFS='|' read -r -a verify_urls <<< "${verify_urls_joined}"

              verified_url=""
              verify_http_code=""
              verify_sha=""

              response_file="$(mktemp)"
              for candidate_url in "${verify_urls[@]}"; do
                query_sep='?'
                if [[ "${candidate_url}" == *\?* ]]; then
                  query_sep='&'
                fi
                probe_url="${candidate_url}${query_sep}verify_attempt=${attempt}"
                verify_http_code="$(curl --silent --show-error --location --header "Cache-Control: no-cache" --header "Pragma: no-cache" --output "${response_file}" --write-out "%{http_code}" "${probe_url}")"
                if [[ "${verify_http_code}" =~ ^2 ]]; then
                  verify_sha="$(sha256sum "${response_file}" | awk '{print $1}')"
                  if [ "${verify_sha}" != "${expected_sha}" ]; then
                    echo "CloudPaste verify checksum mismatch for ${asset}: expected ${expected_sha}, got ${verify_sha}" >&2
                    rm -f "${response_file}" "${verify_queue_file}" "${next_queue_file}"
                    exit 1
                  fi
                  verified_url="${candidate_url}"
                  break
                fi
              done
              rm -f "${response_file}"

              if [ -n "${verified_url}" ]; then
                printf '| `%s` | `%s` | %s | `%s` | `%s` |\n' "${asset}" "${actual_slug}" "${verified_url}" "${verify_http_code}" "match" >> "${GITHUB_STEP_SUMMARY}"
                printf '{"asset":"%s","actual_slug":"%s","download_url":"%s","http_code":"%s","expected_sha":"%s","actual_sha":"%s","sha_match":true}\n' \
                  "${asset}" "${actual_slug}" "${verified_url}" "${verify_http_code}" "${expected_sha}" "${verify_sha}" >> cloudpaste_verify_results.jsonl
              else
                printf '%s\n' "${entry}" >> "${next_queue_file}"
              fi
            done < "${verify_queue_file}"

            mv "${next_queue_file}" "${verify_queue_file}"
            queue_size="$(wc -l < "${verify_queue_file}" | tr -d '[:space:]')"

            if [ "${queue_size}" != "0" ] && [ "${attempt}" -lt "${verify_max_attempts}" ]; then
              sleep "${verify_retry_sleep}"
            fi
          done

          if [ "${queue_size}" != "0" ]; then
            echo "::warning::CloudPaste verify URLs are not readable after ${verify_max_attempts} attempts. Upload API succeeded; marking these assets as pending visibility."
            echo "CloudPaste verify pending assets after ${verify_max_attempts} attempts:" >&2
            cat "${verify_queue_file}" >&2

            while IFS= read -r entry; do
              [ -z "${entry}" ] && continue

              asset="$(python3 -c 'import json,sys; print(json.loads(sys.argv[1])["asset"])' "${entry}")"
              actual_slug="$(python3 -c 'import json,sys; print(json.loads(sys.argv[1])["actual_slug"])' "${entry}")"
              pending_url="$(python3 -c 'import json,sys; print(json.loads(sys.argv[1])["download_url"])' "${entry}")"
              if [ -z "${pending_url}" ]; then
                pending_url="N/A"
              fi

              printf '| `%s` | `%s` | %s | `%s` | `%s` |\n' "${asset}" "${actual_slug}" "${pending_url}" "N/A" "pending" >> "${GITHUB_STEP_SUMMARY}"
              printf '%s\n' "${entry}" >> cloudpaste_verify_results.jsonl
            done < "${verify_queue_file}"
          fi

          rm -f "${verify_queue_file}"

      - name: Upload CloudPaste verification artifact
        uses: actions/upload-artifact@v4
        with:
          name: cloudpaste-verify-results-${{ github.ref_name }}
          path: cloudpaste_verify_results.jsonl
          if-no-files-found: error

  docker:
    name: Build Docker Image
    runs-on: ubuntu-latest
    needs: build-binaries
    steps:
      - uses: actions/checkout@v4

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Get version info
        id: version
        run: |
          VERSION=${GITHUB_REF#refs/tags/v}
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "major=$(echo $VERSION | cut -d. -f1)" >> $GITHUB_OUTPUT

      - name: Build and push
        uses: docker/build-push-action@v6
        with:
          context: .
          platforms: linux/amd64,linux/arm64
          push: true
          tags: |
            ghcr.io/${{ github.repository }}:${{ steps.version.outputs.version }}
            ghcr.io/${{ github.repository }}:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max
